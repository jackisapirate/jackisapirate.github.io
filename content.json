{"meta":{"title":"Hexo","subtitle":"","description":"xxx","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2024-01-01T18:47:06.160Z","updated":"2024-01-01T18:47:06.160Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有分类","date":"2024-01-01T18:47:26.073Z","updated":"2024-01-01T18:47:26.073Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2024-01-01T18:41:02.000Z","updated":"2024-01-01T18:41:02.508Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2024-01-01T18:47:38.303Z","updated":"2024-01-01T18:47:38.303Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"No Stupid Questions Note","slug":"No Stupid Questions","date":"2024-09-13T19:00:00.000Z","updated":"2024-09-13T18:21:55.695Z","comments":true,"path":"2024/09/13/No Stupid Questions/","permalink":"http://example.com/2024/09/13/No%20Stupid%20Questions/","excerpt":"","text":"[TOC] 12345resource example: https://freakonomics.com/series/nsq/《No Stupid Questions》-- Freakonomics Radiohttps://freakonomics.com/podcast/what-makes-a-good-sense-of-humor/资源在B站有搬运，自己搜索 210 No Stupid Questions - What Makes a Good Sense of Humor?off the rails 出轨了，失控了 over the cliff 在悬崖外拉不回来了 开场用I’ve got this great joke. 为什么用have got而非have，因为have got 有我听过的时态，然后引出接下来的话题。have单纯说有这个动作 move on &#x3D;&#x3D; go ahead perpetuate v 使。。持久化，使。。延续 这里在说让我们的物种、基因延续 prior a 以前的，之前的 previous No. 1 box office smash hit 热映榜首 fell under the categorization of 属于。。目录&#x2F;类型下 hit me so hard 非常用力地打(动)我 uncontrollably adv 控制不住地 for days after 几天后 be amused 被逗乐 例如你被逗出猪叫 subject line 说的是邮件主题 abduct v 绑架，劫持 fell out of 就这个连读 trauma n 创伤，精神创伤 be reflecting on 反思，深思 reflect 这个词用作反思 unnoticed a 未引起注意的 traumatic a 痛苦的，创伤的 come upon this gem 知道的这个爆梗 巧遇这个珍宝 obituary n 讣告，死讯 fact checked it 核实真相 bludgeon v 大棒重击，恫吓 hysterical 歇斯底里的 self preservation mechanism 自我保护机制 adaptive a 适应的 adrenaline and cortisol 肾上腺素和皮质醇 tribe 部落，一伙儿 have your back 做你的后盾，支持你 evolutionary a 进化的 vocalization n 发声 intention n 意图，目的 tickle v 咯吱，挠痒 speculate v 推测 defend something 一般来说表示守卫something, 如果是抵御A免遭B侵袭 defend A against B constructive manner 建设性的方式 voice box 喉 这里不是指公寓门前的门铃 communicative threaten v 威胁 t 不发音 laugh tracks 音轨(情景喜剧里哈哈哈的背景笑声) fledgling 雏儿，新手 piped 这里是表示插入的的意思 communal a 公共的，共享的 bring it up 提出来 integrative a 综合的，一体的 antecedent n 先行词，祖先 right off the bat 立刻马上 ingredient n 成分，要素，菜谱的配料 hypothesize v 假设 recipe 食谱 active ingredient 有效成分，活性成分 就是指发挥作用的成分 superiority n 优势，优越感 expense n 这里是代价 是说取笑别人，拿消遣别人为代价 wit that offends 冒犯的智慧 subordinate a 次要的，隶属的 n 下级 v 使隶属于。。。 quote unquote 带引号的 benign a 善良的，和善的，良性的 juxtaposition n 并列 wavelength n 波长 vibe 共鸣，共振 figuratively adv 比喻地，象征性地 sweet spot 最佳击球点 exclusivity n 专有性，独特性 voice memo 语音备注，语音备忘 harness v 利用 n 马具；挽具 strengthen v 加强 注意发音 diffuse v 弥漫，散布 a 弥漫的，扩散的 resilience n 适应力，弹力，恢复力 stakes n 赌注 deadly a adv 非常，极度，十分的 yearn v 渴求 humanize v 使更适合人，教化 approachability n 可接近性 self deprecating 自嘲的，自谦的 slink off stage 悄悄下台 slink 悄悄溜掉 deadpan a adv n 面无表情的，冷面 juxtapose v 把。。并列 misread v 误读，念错 mis_read craft n 工艺，手艺，飞行器 craft of writing 写作技巧 transcribe v 抄录，转写，改作 Swedish n.瑞典语, 瑞典人 Sweden n 瑞典 Switzerland n 瑞士 Scandinavian n.北欧(人)的；斯堪的纳维亚语(的) charisma n.超凡的个人魅力；感召力；号召力 captivate v 迷住，使着迷，吸引 you’d think 表示推测“你会认为”，这里‘d几乎不发音，需要上下文推断 somber a 忧郁的 uproarious a 喧嚣的 eulogy n 颂词，悼词 ebb n 落潮 v 衰退 approachable a 和蔼可亲的，平易近人的 exceptional circumstances 特殊情况，意外情况 give you credit for something 这里的credit是认可 inadvertently adv 无意中地 biting a 刺骨的，尖锐的 roast them 这个词本来是烤的意思，但是对人是说说某人糗事的宴会 cringey a 令人尴尬不适的，畏缩的 myth n 神话，黑神话悟空用的这个词表示神话 paralyze v 使瘫痪，使麻痹 impact v 影响，冲击 perception n 感知，知觉，看法 competence n 能力，技能，权限 informative a 提供有用信息的 immensely adv 非常，极端地 willingness 意愿 abysmal a 糟糕的 heartbeat n 心跳 注意这个词是名词 roll one’s eyes 翻白眼 roll off his chair 从椅子上滚下来 deep end 可以表示深渊，深水区 look for times 这里的times refers to opportunities or moments changes n 几率 right amount of 适当的数量的 hearken v 倾听 mindset n 思维方式，心态 growth n 生长，增长，发育 juggle 杂耍 One reason I beg to differ is that 我不同意的一个原因是 autobiographical a 自传的 autobiographic 的变体 be obsessed with 痴迷于 expertise n 专业知识，专业技能 pop tart 玉米饼状的吃的 pastry 油酥甜点总用这个词 buffing and polishing 抛光 premeditated 预谋的，蓄意的 spontaneity n 自发性 off the cuff adv 即兴的 think through 仔细考虑 extraordinary a 意想不到的，非凡的 massively adv 大规模地，厚重地，庄严地 rehearse v 排练 hearken back to 回想起 per se 本身，本质上 wallow 沉溺 funk 沮丧，抑郁 it got me out of a funk 让我摆脱了抑郁 is often credited as 通常被认为是 novelty n 新奇 a 风格独特的 composition n 成分，构成，作曲 Puritan 清教徒 air v 播出 orchestrate v 谱写，精心策划 awareness n 意识，察觉 fatality n 宿命，致命死亡 campaign n 战役，活动 imperial a 帝国的，皇帝的 n 写字纸 imperial system 这里的system为制度，度量，分类规则 masochism n 后虐狂 freakonomics 怪诞经济学 这个词是一个合成词 123456Some sentencesOur emotions fundamentally serve the purpose of our survival, but how does laughing or being funny prevent us from being eaten by a lion?I don&#x27;t think like oh &quot;funny&quot; would be in the top 40 adjectives that anybody would use to describe me.Sometimes you&#x27;re laughing at someone else&#x27;s expense.Humor obviously impacts our perception of status competence confidence etcwhat are the chances that the two main comics hosting late night shows (they)&#x27;re both named Jimmy.","categories":[{"name":"English","slug":"English","permalink":"http://example.com/categories/English/"}],"tags":[{"name":"English learning","slug":"English-learning","permalink":"http://example.com/tags/English-learning/"}]},{"title":"English Pod Note","slug":"English Pod Note","date":"2024-09-13T19:00:00.000Z","updated":"2024-09-13T18:24:06.962Z","comments":true,"path":"2024/09/13/English Pod Note/","permalink":"http://example.com/2024/09/13/English%20Pod%20Note/","excerpt":"","text":"[TOC] 001 Elementary ‐ Difficult Customer (B0001)12345678910111213dialogue v.n 对话involved 理解为参与好一点 Two people are involved.May i take your order? 点菜用语be still working on it 介词 on 当别人问任务做完了没，可以用这个回答 I still need more time.come with 附带 语气就是(附)带薯条可乐么？complimentary a 免费的 free的替换词I will go with something/someone 做选择时候可用I will choose/take；或者表示我跟你一起去 I&#x27;ll go with U.angry at 对某人生气时候 朝向的介词用atfinish reading 完成某事 finish doingcasual 啧啧啧，随便！short way of saying... 缩写until then adv 在那之前001 Elementary ‐ Difficult Customer (B0001) 002 Elementary ‐ Calling In Sick (B0002)123456789101112131415161718quite ill 病的很重，很难受 I&#x27;m feeling quite illsynonym n 同义词once in a while 偶然call in sick 打电话请病假keep one&#x27;s ears open 竖起耳朵听runny nose 流鼻涕的鼻子feverish n 发烧 ~ish后缀be hoping to do 委婉请求take the day off 歇一天get some rest 休息的动作convinced 确信的I am coming down with the flu. 表示得病的前期，有点“我要感冒”impolite a 不礼貌的would have been 虚拟语气that would have been really bad for me... 那你上礼拜要是请假，那不就我一个人录节目了though 表示“不过”的语气speculation n 猜想，推测out of time a 没时间了 003 Elementary ‐ Daily Life ‐ Hotel Upgrade12345678910reservation under the name xxx 某人名下的预约we&#x27;ve been expecting you 我们一直在等你。注意时态用法keycard 房卡presidential suite 注意套房和sweet发音一样overbooked 订满了mix-up n 乱套，混乱come in handy 迟早要用上in case 以防万一震惊，印度火车升级为1st class座位five-course meal 五道菜，西餐的流程说法 004 Elementary ‐ The Office ‐ I need an assistant!123456789101112help you with your work around your offic. 介词 help ... with 还有这个around用的很厉害表示在办公室各个方面，如果用in只表示在办公室里会有个人帮你，不会强调广泛性help out 帮忙give me a hand 帮我一把，帮把手understaffed a 缺人手的the timing is just not right 这时候不合适，时机不对take on v 雇佣，担任 hireget hired by the companytake some of the weight off my shoulders 为我分担负担keep our costs down 省钱，省预算meet her 这里t变d，her的h被吞掉了，感觉her的h总不发音elaborate on that 阐述一下某件事sexist n 性别歧视者 005 Elementary ‐Daily Life ‐ Cut In Line12345678910111213141516cut in line 插队 When you are standing in a line somewhere, and somebody gets in front of you.It takes/took two hours to do somethinggo on vacation 度假course 常用于课程，在这是球场 golf course 不是高尔夫球课No seriously 不是吧I was here first 这个first表示第一个地，中文理解为我先到的says who 谁说的？这句话倒装了sue me 你告我去呀！impatient a 急躁的，没耐心的point out 指出no way 没门儿！ It is impossible!impolite a 不礼貌的take it seriously 对某事很认真严肃英国妹解释jump a/the queue，英国人的反应会指桑骂槐，they do it very obviously, speak it out loud.escalator n 自动扶梯 006 Elementary ‐ The Weekend ‐ Road Trip1234567891011road trip 自驾游the car&#x27;s packed 某物打包好了 everything you need is inside the carmunchies n 零食 snacksfill up the tank 加满油 put gas in your carall set 都完事了we&#x27;ve got all our bases covered 把基本情况都考虑进去了，准备好了let&#x27;s get going 开始吧pit stop 加油站，补给站，中国的高速服务区we&#x27;ve only been on the road ...hurricane hits 飓风袭击get down to business 开始做正事吧 007 Elementary ‐ The Office ‐ Virus!12345678910virus n 病毒pick up a virus 感染病毒froze v freeze 描述电脑卡了 your PC stops working.act up 出毛病，调皮捣蛋I&#x27;ll be right up 马上上来 be right there/down/outinfected files 中毒的文件anti-virus software 杀毒软件up to date a 最新的 This is the most up to date map.how come == whyturns out that 结果是 008 Elementary ‐ Daily Life ‐ What’s your nameagain? (C0008) 12345678conference n 研讨会I am in a bit of a hurry. 我有点急事meet up 偶尔见面，常联系contact details n 联系方式Something just slipped my mind. 忘了be terrible with name too 不擅长people can get in touch with you. 联系到你Is it a bank around here. right around the corner. adv 表示附近 009 Elementary ‐ The Weekend ‐ Silence please!12345678910speaking of movies 说到电影呢。。。展开话题用语movies n 电影院 cinema, movie theaterinconsiderate a 不体谅别人的keep it down 小点声 be quietswitch it off 关掉 turn it offnot such a bit deal: it is not importantcan&#x27;t hear a thing.Do you mind keeping it down?sarcastic a 讽刺的tone of voice 语气 010 Elementary ‐ The Office ‐ Driving Sales1234567891011drive sales 促销promotion n 促销和升职都可以用这个词 job promotionbuy one get one free which is a two for one promotionconcrete a 具体的，实际的How do you intend to do something? 你有什么想法？It&#x27;ll never fly with Swan. Swan 不会同意的I kind of like the sound of that. 这个听起来不错match the competitors 与竞争对手匹敌It sounds like something we should consider.brilliant a 牛Bcut them off 打断他们 011 Elementary ‐ Daily Life ‐ New Guy in Town1234567891011121314151617181920gossip v.n 八卦 gossip girl; gossip on somebodyweird == oddhousewarming gift 乔迁礼物pastry n 油酥点心I don&#x27;t know if you heard, ... 当你想分享八卦的时候的开场白fill me in 让我知道，快告诉我practically adv 简直，几乎peek into 瞥一眼，搂一眼you&#x27;ll never guess 另一个分享八卦的开场白pull into （车）停进，驶入coffin n 棺材you scared the heck out of me 你tm吓死我了 creep me outover 邀请别人来自己家都和这个介词有关get a bad feeling about someone 呃呃kick me out 把我踢出，轰出 they forced you to leavemisbehave v 行为不端car wrecking yard 废车场 scrap yardtake the part apart to sell 表述从wrecked car 上拆零件去卖moved away 搬走了juicy story n 爆料 012 Elementary ‐ Daily Life ‐ Cleaning the House123456789101112such a mess 乱成这样！disorganizedchores n 家务 do the laundryin the middle of something 正做。。事情，我正干。。事情 tidy up 收拾，打扫spotless a 一尘不染，无瑕dust v.n 名词是粉尘，灰尘 动词是擦去尘土，掸去on your way home 在回家的路上set the table 摆桌vacuum v 用吸尘器吸这的个动作 hoover the ruggrocery n 杂货，日用品I&#x27;ll be there in a sec. I&#x27;ll be there soon.why don&#x27;t you do something. how about you do something. You’ve known me for years? For me, I think this is the end of a beautiful friendship. 013 Elementary ‐ The Office ‐ Out Of Control Spending12345678910expenses n 费用，花费expenditures n 也是费用，开销，这个词更偏向于总体花费，比较宏大，类似聊经费预算office supplies 办公用品through the roof 直线上升，暴涨，（budget）烧穿房顶off the charts 超出预期，爆表that will be all 就这样吧！thorough adv.a 完全地，彻底地go over 仔细检查，排练，过一遍I will look into it 我会注意/看看的 check somethingI will take care of it 我会处理好它 014 Elementary ‐ I’m in Debt12345678in debt adv 背着债务，欠人钱 If I owe you money, I&#x27;m in debt.recession n 经济萧条hit me pretty hard 对我打击很大，重击broke a 破产了mortgage 贷款on top of all that 另外，除此以外ask for a loan v 借贷francs 法郎 015 Elementary ‐ Daily Life ‐ I’m sorry, I love you12345678knock over 击倒，撞倒 make it fall down 和 knock out 一样 KOexplode v boommean to do 故意做 on purposeget going 出发someone&#x27;s place 就是指someone’s housecoincidence n something happens by chanceI feel terrible 可以表示内疚难过we are so you think 就是你想的那样 016 Elementary ‐ Turn left here!123456789101112in a big hurry 匆忙speed up 加速slow down 减速what&#x27;s the rush! 着什么急!step on it 加大油门 drive fasternuts a 疯了的run a red light 闯红灯packed a 拥挤的，大量的take a side street 走小路have a fit 大发雷霆 get really angry, can&#x27;t control emotions.short cut 捷径cut through 穿过 go thru 017 Elementary ‐ Here Comes the Bride12345678groom n 新郎 the man is getting marriedaisle 过道 超市里面shelving units 之间的过道常用这个词ring bearer 持戒人priest 神父，牧师reception n 老美那种室外的自助partyit&#x27;s about time 该到时间了表达结婚要用get marriedWhen I get married, I wanna a huge wedding. 018 Elementary ‐ Upper ‐ Intermediate ‐ Protest!12345678910protest v.n 抗议bankrupt 倒闭，破产bailout 紧急救助，紧急财政援助irresponsibility n 不负责outrage v 激怒 n 愤怒，暴行mismanage v 对。。管理不当have the nerve to 好意思去做，舔着脸去做，厚颜无耻 how dare youfurious a 狂怒的，暴怒的injustice n 不公平，不公正break out 爆发 019 Elementary ‐ The Weekend ‐ Christmas Chronicles I1234567891011121314缺少的半句话：the state will appoint one for you. Do you understand all these rights that have just been read to you?eggnog 蛋奶酒get a load of 仔细看we&#x27;ve got ourselves a situation 我们遇到了状况’tis == it isDon&#x27;t take that tone with me 别用那种口气跟我说话invoice 发票under arrest adv 被捕了pout 撅嘴生气appoint v 任命，委派sleigh 雪橇get help 去求救，去叫人帮助step out 走出来 step in 走进去 santa的每只鹿都有自己的名字 020 Elementary ‐ I Can See Clearly Now12345678910struggle to do 努力做某事，挣扎着做某事blurry a 模糊的，难以理解的 blur v 使模糊prescription 药方make out 辨认出，理解，发现 at times 有时候20/20 vision 等同 5.0视力nearsighted 近视眼的blind as a bat 像蝙蝠一样的好眼力what seems to be the prob?head on 去，到 021 Elementary ‐ The Office ‐ What Do You Do?123456789101112缺少的半句话：daily operations of our quality control for the entire east coast that alone means I have 1500 employees under me.Fortune 500 世界500强nationwide 全国的under me 下属 working for meoversee 监视quality control 质量控制that alone means 仅仅这一点就意味着chosen by MoiraTop Gun 《凌云壮志》sarcastic tone 得瑟嘲讽的语气is going on about xx 谈论关于xx keeps talking aboutwhat do you do for living? 你干什么工作的？比what&#x27;s your job?地道地道地道It doesn&#x27;t sound natural. 022 Elementary ‐ The Weekend ‐ Christmas Chronicles II123456789elf n 精灵 little people with pointy hats 带着尖尖的帽子candy cane 拐杖糖book v 可以用作警察将某人的违法行为记录在案，可以理解为逮捕 booked this guy.reindeer 驯鹿Mayday 呼救就会喊这个backup 这里是增援 call for backup 注意发音 否则是后退的意思形容超速 you were/are speeding.impound v 拘禁，扣押ruined destroyed messed up 023 Elementary ‐ Making an Appointment1234567financial advisor 财务顾问，理财顾问arrange an apponinment with Someone 预约的时候动词可以不总用make/bookbooked solid 日程排满了 记得我们之前学的订超了 overbookedI&#x27;ve got something scheduled on Monday 我周一有约了/有事 scheduled 预定好的May I ask where your&#x27;re calling from? 你哪个单位？你谁？no good 不好 Tuesday&#x27;s no good. 周二不好，拒绝别人时候可以这么表达double check 非常常用的表达“我看看”，“我再检查一下” let me double check 024 Elementary ‐ Where should we eat?12345678910food poisoning 食物中毒 get food poisoningallergic a 过敏的 I&#x27;m allergic to seafood.stay away v 躲开check out 文中的check out是去看一看(吃一次)的意思 look atdecor n 装饰，装修bistro n 小店，小餐馆platter n 大盘儿，大拼盘a hole in the wall 苍蝇馆儿，简陋的小店give them a try 试一下tasty a 美味的，可口的，好吃的 025 Elementary ‐ Upper ‐ Intermediate ‐ Planning For The Worst1234567891011be managed to do 设法做某事order of business 这个词表示议程 something we must discusscontingency n 偶发，突发事件 backup planpandemic a 大流行的 n 传染病a pandemic strikes 疫情来袭as many of you are aware 你们很多人都知道head up 指挥，主导critical a 重要的，关键的come up with == think ofmedia coverage 媒体报道 coverage 新闻报道，覆盖范围I&#x27;ll leave this to you. 交给你了，留给你了 026 Elementary ‐ New Year Resolution12345678eating habits 饮食习惯New year&#x27;s resolution 新年愿望，或者叫新年立志，我今年一定要。。。cut out 割掉，除去，停止 cut out all junk I eat 戒垃圾食品 remove/eliminate/take it awayIt&#x27;s time for me to focus on my work. I&#x27;m going to cut out everything else from my life.stick to something/it 坚持某事，坚守某事I really mean it 我认真的 I am seriouswait and see 拭目以待 某外交部记者会常用词汇I&#x27;m stuffed == I&#x27;m full 饱了，撑了","categories":[{"name":"English","slug":"English","permalink":"http://example.com/categories/English/"}],"tags":[{"name":"English learning","slug":"English-learning","permalink":"http://example.com/tags/English-learning/"}]},{"title":"java question","slug":"java_question","date":"2024-01-10T20:00:00.000Z","updated":"2024-01-10T20:14:47.317Z","comments":true,"path":"2024/01/10/java_question/","permalink":"http://example.com/2024/01/10/java_question/","excerpt":"","text":"[TOC] java43 Abstract class vs. Interface. When to use abstract class and when to use interface?","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"interview","slug":"interview","permalink":"http://example.com/tags/interview/"}]},{"title":"vocabulary","slug":"vocabulary","date":"2024-01-03T05:37:24.000Z","updated":"2024-03-19T07:50:10.519Z","comments":true,"path":"2024/01/02/vocabulary/","permalink":"http://example.com/2024/01/02/vocabulary/","excerpt":"","text":"[TOC] 2000Text 1 1234567891011121314151617181920212223242526272829303132333435363738394041effortless a 不费力的dreadful a 糟糕的，令人讨厌的handicap n 障碍，缺陷driving force n 驱动力competitor n 竞争者unparalleled a 无可匹敌的economies of scale 规模经济prosperous a 繁荣的inevitable a 不可避免的primacy n 首要retreat v.n 撤退predominance n 优势，主导地位，支配地位at a loss over 面对。。的时候不知所措competitiveness n 竞争力vanish v 消失textile n 纺织品，纺织业sweeping into 涌入，席卷，横扫looked as though 看起来像semiconductors n 半导体invented a 发明casualty n 受害者crisis n 危机prosperity n 繁荣take … for granted 把。。当成理所应当的inquiry n 调查sensational a 轰动的，耸人听闻的look back 回顾solely ad 仅仅地，单独地devalued 贬值的yielded to v 屈服于quick-witted a 明智的dean n 院长productivity n 生产力think-tank n 智库painstaking a 辛苦的workforce n 劳动力impetus n 动力，刺激manifested v 证明，表明suicidal actions 自杀行为revival n 复苏be attributed to 归因于","categories":[],"tags":[{"name":"en","slug":"en","permalink":"http://example.com/tags/en/"}]},{"title":"Hello World","slug":"hello-world","date":"2024-01-01T10:01:37.983Z","updated":"2024-09-13T18:23:35.448Z","comments":true,"path":"2024/01/01/hello-world/","permalink":"http://example.com/2024/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment I have to say the version of NPM, in case I forgot it. 1v18.9.0","categories":[],"tags":[]},{"title":"Leetcode75","slug":"Leetcode75","date":"2023-09-11T19:00:00.000Z","updated":"2024-06-04T07:08:07.266Z","comments":true,"path":"2023/09/11/Leetcode75/","permalink":"http://example.com/2023/09/11/Leetcode75/","excerpt":"","text":"[TOC] https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions Binary 和 Dynamic Programming不用看 关于循环的描述 1I am looping through this array using a for loop, and each time, I print the value of the element. 常用方法汇总 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970map.containsKey(key)map.putmap.getmap.getOrDefault(Object key, V defaultValue);创建一个带参数的map：public static HashMap&lt;Character, Character&gt; map = new HashMap()&#123;&#123;put(&#x27;(&#x27;, &#x27;)&#x27;);put(&#x27;[&#x27;,&#x27;]&#x27;);put(&#x27;&#123;&#x27;,&#x27;&#125;&#x27;);&#125;&#125;;map.keySet()map.values()Set&lt;String&gt; keySet = hashMap.keySet(); Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = hashMap.entrySet(); for (Map.Entry&lt;String, String&gt; entry : entrySet) &#123; System.out.println(entry.getKey() + &quot;-&quot; + entry.getValue()); &#125;set.contains(value) 查看是否有值其中一种写法可以返回add的值，判断是否containsif (!set.add(x)) &#123; return true;&#125;字符串字符串返回特定index上的字符是str.charAt(index)或者先把字符串打成数组：str.toCharArray()s.substring(l, r); // r不包括 广度优先 queueQueue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();queue.addqueue.offer(i);queue.removeint u = queue.poll();PriorityQueue&lt;Status&gt; queue = new PriorityQueue&lt;Status&gt;();PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;() &#123; public int compare(int[] m, int[] n) &#123; return m[1] - n[1]; &#125;&#125;);Deque&lt;ListNode&gt; stack = new LinkedList&lt;ListNode&gt;();// 数组Arrays.fill(dp, amount+1); db[0]=0char[] charArray = s.toCharArray();int[][] arr = list.toArray(new int[list.size()][]); list转数组LinkedList&lt;Character&gt; stack = new LinkedList();stack.offer(&#x27;?&#x27;); stack.addLast(c); 注意对于栈这两个不是标准方法stack.push(c);stack.size();char temp = stack.pop(); stack.removeLast();List 转数组int[] intArray = myList.stream().mapToInt(Integer::intValue).toArray();Integer[] integerArray = list.toArray(new Integer[0]);System.out.println(Arrays.toString(integerArray));ArrayList泛型 List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;List&lt;Integer&gt;&gt;();对字符的判断Character.isLetterOrDigit(s.charAt(left))sgood.append(Character.toLowerCase(ch));StringBuffer sgood_rev = new StringBuffer(sgood).reverse();compareArrays.sort(intervals, (v1, v2) -&gt; v1[0] - v2[0]);Arrays.sort(intervals, new Comparator&lt;int[]&gt;()&#123; public int compare(int[] interval1, int[] interval2)&#123; return interval1[0] - interval2[0]; &#125;&#125;); Array 101.Two Sum12345Map泛型必须用类Integer，不能是int这种基本类型map.containsKey(key)map.putmap.get存储的是以当前元素为key，寻找的是target-当前元素的值为key en note 123456789101112131415161718It might be tempting to say 可能禁不住会说add up 加起来add up to five 加起来等于5表示一个[1，4]数组可以说It is an array of 1, 4.time and space complexityend up 最后是I&#x27;ll see that the time ends up being O ...n squared n的二次方，注意是过去式look in v 查找，顺便看看stumble upon 碰上，遇到keep track of.. 追踪，密切关注，记录 这里是记录已经看过的数据later on 随后doesn&#x27;t look like it does. 看着不像subtract v 减去 If I subtract 3 from my 1, we&#x27;ll get negative 2.It doesn&#x27;t matter the order. 顺序不重要，It doesn&#x27;t matter 后面可以直接加it指代的名词Because I iterate once through the array. 遍历了一遍数组start out by doing 首先从doing出发/开始 121.Best Time to Buy and Sell Stock1234初始的最小金额可以设置成Integer.MAX_VALUE也可以先检查数组长度，如果长度大于0，就将第一个值赋值给记录最小值的变量iterate through the array 形容便利一个数组的时候 217.Contains Duplicate12345set.contains(value) 查看是否有值其中一种写法可以返回add的值，判断是否containsif (!set.add(x)) &#123; return true;&#125; 238.Product of Array Except Self 成积前缀后缀乘积，空间复杂度控制n，需要背下来，开始根本记不住，现在完全能盲写 1234567891011121314public int[] productExceptSelf(int[] nums) &#123; int len = nums.length; int[] answer = new int[len]; answer[0] = 1; for(int i=1; i&lt;len; i++)&#123; answer[i]=answer[i-1] * nums[i-1]; &#125; int r = 1; for(int i=len-1; i&gt;=0; i--)&#123; answer[i] = answer[i] * r; r *= nums[i]; &#125; return answer;&#125; en note 12prefix n 前缀suffix n 后缀 53.Maximum Subarray用动态规划解题，有点像计算前序和，后续和 1234567891011121314151617181920212223242526272829303132 public int maxSubArray(int[] nums) &#123; int len = nums.length; int[] dp = new int[len]; dp[0] = nums[0]; int result = dp[0]; for(int i=1; i&lt;len; i++)&#123; if(dp[i-1] &lt; 0)&#123; dp[i] = nums[i]; &#125; else&#123; dp[i] = dp[i-1] + nums[i]; &#125; result=result&lt;dp[i]?dp[i]:result; &#125; return result; &#125;// 改进：只需要记录当前sum就可以了// 用sum记录前序和，当前序和小于0，就用当前值做前序，否则就累加当前值 public int maxSubArray(int[] nums) &#123; int sum = nums[0]; int max = nums[0]; for(int i=1; i&lt;nums.length; i++)&#123; if(sum&lt;0)&#123; sum = nums[i]; &#125; else &#123; sum += nums[i]; &#125; max = max&lt;sum? sum : max; &#125; return max; &#125; en note 1subarray 这个词指代连续的一段子数组 152.Maximum Product Subarray12345计算截至到当前数字的最大区间的最大积Math.max(mn*nums[i], Math.max(mx*nums[i], nums[i]));，和最大区间的最小积Math.min(mn*nums[i], Math.min(mx*nums[i], nums[i]));，和当前最大积result也是类似dp的思路，只是记录两个dp 1234567891011121314151617public int maxProduct(int[] nums) &#123; if(nums.length == 0)&#123; return 0; &#125; int result = nums[0]; int mxResult = nums[0]; int mnResult = nums[0]; for(int i=1; i&lt;nums.length; i++)&#123; int current = nums[i]; int mx = mxResult, mn = mnResult; mxResult = Integer.max(current*mn, Integer.max(current, current*mx)); mnResult = Integer.min(current*mn, Integer.min(current, current*mx)); result = Integer.max(result, mxResult); &#125; return result;&#125; 153.Find Minimum in Rotated Sorted Array二分法，找不是ascending的那两个数字感悟这个比较过程，当med小于high时候，说明med到high都是顺序，则pivot可能在left到med之间，所以high&#x3D;med. 123这个算法有两个点注意1：中间点是final int m = (left + right) / 2;2：先检查后半部分是否符合标准，符合则right=m；不符合则left=m+1；这样不会出现越界现象，中间点赋值时候不会等于右边点。 33.Search in Rotated Sorted Array需要背 首先给定的数组分为两部分，前升序和后升序。这里的后升序的最大值小于前升序的最小值。 然后先找med的值，和target比较。再和left和right比较，在这个区间就缩小范围，不在这个区间就尝试下另外一个范围。 1nums[0]&lt;=nums[med] 先用上面的代码分出前还是后升序 然后再分出是有序部分还是无序部分 15.3Sum需要背，现在也不用背了 先排序 两个For 循环（进入循环后去重） + 双指针 1关于not contain duplicate triplets的问题，可以自己查重，也可以用set去重 11.Container With Most Water双指针，往里面缩短板，可能会得到更大的面积，往里面缩长板，长变小，高不变，一定会得到更小的面积。因此策略是双指针向内缩短板。 Binary 5371.Sum of Tow Integers不能用+-符号，思路是位运算符号 12345bit-wise operators &amp; (and), | (or), ~ (not) and ^ (exclusive-or, xor) and shift operators a &lt;&lt; b and a &gt;&gt; b.进位 carry进位的值用 a &amp; b 然后左移1位 最终表示为：(a&amp;b) &lt;&lt; 1无进位的值 a ^ b二者的值相加，直到进位为0（也就是没有需要进1的位），说明本轮这次a ^ b就是最终结果。 191.Number of 1 Bits1234567每次n &amp; (n−1)都把n的最低的1位变成了0，所以统计这个运算的次数 int output=0; while(n!=0)&#123; n &amp;= (n-1); output++; &#125; return output; 338.Counting Bits4种解法，基本是动态规划的逻辑，用已经算出的数字推演当前数字 268.Missing Number123456789101112public int missingNumber(int[] nums) &#123; int xor = 0; int n = nums.length; for (int i = 0; i &lt; n; i++) &#123; xor ^= nums[i]; &#125; for (int i = 0; i &lt;= n; i++) &#123; xor ^= i; &#125; return xor;&#125;// 当一个数字^两次同样的数字后为0 190.Reverse Bits左右不停颠倒题。。。123456789101112131415161718192021public int reverseBits(int n) &#123; int rev = 0; for (int i = 0; i &lt; 32 &amp;&amp; n != 0; ++i) &#123; rev |= (n &amp; 1) &lt;&lt; (31 - i); n &gt;&gt;&gt;= 1; &#125; return rev;&#125;private static final int M1 = 0x55555555; // 01010101010101010101010101010101private static final int M2 = 0x33333333; // 00110011001100110011001100110011private static final int M4 = 0x0f0f0f0f; // 00001111000011110000111100001111private static final int M8 = 0x00ff00ff; // 00000000111111110000000011111111public int reverseBits(int n) &#123; n = n &gt;&gt;&gt; 1 &amp; M1 | (n &amp; M1) &lt;&lt; 1; n = n &gt;&gt;&gt; 2 &amp; M2 | (n &amp; M2) &lt;&lt; 2; n = n &gt;&gt;&gt; 4 &amp; M4 | (n &amp; M4) &lt;&lt; 4; n = n &gt;&gt;&gt; 8 &amp; M8 | (n &amp; M8) &lt;&lt; 8; return n &gt;&gt;&gt; 16 | n &lt;&lt; 16;&#125; Dynamic Programming 1170.Climbing Stairs123上台阶，一次可以上1级或者2级台阶，问多少种走法当i&gt;=3时候output[i] = output[i-1] + output[i-2]; 322.Coin Change1234567891011121314public int coinChange(int[] coins, int amount) &#123; int output = 0; int[] dp = new int[amount + 1]; Arrays.fill(dp, amount+1); dp[0] = 0; for(int i=1; i&lt;amount+1; i++)&#123; for(int j=0; j&lt;coins.length; j++)&#123; if(coins[j] &lt;= i)&#123; dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1); &#125; &#125; &#125; return dp[amount]&gt;amount? -1: dp[amount];&#125; 1234dp 只一个数组的解法，长度是amount+1初始化用Arrays.fill(dp, amount+1); db[0]=0两个for循环,外循环是amount,从1开始，内循环是coins的长度，从0开始最后比较dp[amount]值是否被改变过 300.Longest Increasing Subsequence1234567891011121314151617public int lengthOfLIS(int[] nums) &#123; if(nums.length&lt;=1)&#123; return nums.length; &#125; int[] dp = new int[nums.length]; Arrays.fill(dp, 1); int output = 1; for(int i=1; i&lt;nums.length; i++)&#123; for(int j=i-1; j&gt;=0; j--)&#123; if(nums[j]&lt;nums[i])&#123; dp[i] = Math.max(dp[i], dp[j]+1); output = Math.max(output, dp[i]); &#125; &#125; &#125; return output; &#125; 1每次记录output 12345678910111213141516171819202122232425262728// dp算法很好理解，以下是贪心d数组记录每个i位置的最小结尾数字，不断更新这个结尾数字。用二分提高查找效率，这个算法不好理解 public int lengthOfLIS(int[] nums) &#123; int len = 1, n = nums.length; if (n == 0) &#123; return 0; &#125; int[] d = new int[n + 1]; d[len] = nums[0]; for (int i = 1; i &lt; n; ++i) &#123; if (nums[i] &gt; d[len]) &#123; d[++len] = nums[i]; &#125; else &#123; int l = 1, r = len, pos = 0; // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0 while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (d[mid] &lt; nums[i]) &#123; pos = mid; l = mid + 1; &#125; else &#123; r = mid - 1; &#125; &#125; d[pos + 1] = nums[i]; &#125; &#125; return len; &#125; 1143.Longest Common Subsequence1234如果相等，就dp[i-1][j-1] + 1如果不等，就Math.max(dp[i-1][j], dp[i][j-1])字符串返回特定index上的字符是str.charAt(index)或者先把字符串打成数组：str.toCharArray() 123456789101112131415161718public static int longestCommonSubsequence(String text1, String text2) &#123; int[][] dp = new int[text2.length() + 1][text1.length() + 1]; for(int i=0; i&lt;text2.length()+1; i++)&#123; int[] cur = new int[text1.length() + 1]; dp[i] = cur; if(i!=0)&#123; for(int j=1; j&lt;text1.length() + 1; j++)&#123; if(text1.charAt(j-1) == text2.charAt(i-1))&#123; dp[i][j] = dp[i-1][j-1] + 1; &#125; else&#123; dp[i][j] = Math.max(dp[i][j-1], dp[i-1][j]); &#125; &#125; &#125; &#125; return dp[text2.length()][text1.length()];&#125; 139.Word Break12主要是条件不好想dp[j] &amp;&amp; set.contains(s.substring(j, i)) 1234567891011121314public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; Set&lt;String&gt; set = new HashSet(wordDict); boolean[] dp = new boolean[s.length() + 1]; dp[0] = true; for(int i=0; i&lt;=s.length(); i++)&#123; for(int j=0; j&lt;i; j++)&#123; if(dp[j] &amp;&amp; set.contains(s.substring(j, i)))&#123; dp[i] = true; break; &#125; &#125; &#125; return dp[s.length()];&#125; 377.Combination Sum IV123这个dp代表当前target从0-target值每一轮是当前硬币组成当前target的可能性，只考虑当前硬币在当前位置上dp[i] += dp[i-num] 123456789101112public int combinationSum4(int[] nums, int target) &#123; int[] dp = new int[target + 1]; dp[0] = 1; for(int i=1; i&lt;=target; i++)&#123; for(int coin:nums)&#123; if(coin&lt;=i)&#123; dp[i] += dp[i-coin]; &#125; &#125; &#125; return dp[target];&#125; 198.House Robber1234567891011121314// 一次迈两步还是一次迈三步的问题，这个问题比较简单public int rob(int[] nums) &#123; int[] dp = new int[nums.length + 1]; dp[0] = 0; dp[1] = nums[0]; for(int i=2; i&lt;=nums.length; i++)&#123; if(i-3&lt;0)&#123; dp[i] = dp[i-2] + nums[i-1]; &#125; else&#123; dp[i] = Math.max(dp[i-3], dp[i-2]) + nums[i-1]; &#125; &#125; return Math.max(dp[nums.length], dp[nums.length-1]);&#125; 213.House Robber II1闭环以后，逻辑就变成(0, len-2)或者(1, len-1)谁更大的问题，这题要考虑len==1和len==2的情况 12345678910111213141516171819public int rob(int[] nums) &#123; int length = nums.length; if (length == 1) &#123; return nums[0]; &#125; else if (length == 2) &#123; return Math.max(nums[0], nums[1]); &#125; return Math.max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1)); &#125; public int robRange(int[] nums, int start, int end) &#123; int first = nums[start], second = Math.max(nums[start], nums[start + 1]); for (int i = start + 2; i &lt;= end; i++) &#123; int temp = second; second = Math.max(first + nums[i], second); first = temp; &#125; return second; &#125; 91.Decode Ways12345转移方程1：当第i个字符不是&#x27;0&#x27;,说明当前字符自成一个字母，那么dp[i] = dp[i-1]2：当第i-1个字符不是&#x27;0&#x27;，且第i-1个字符和第i个字符能组成一个新的字符，也就是&lt;=26，则dp[i] = dp[i-2]上述2点可能同时发生，因此第二条应该累加 dp[i] += dp[i-2]，且当i为起始点的时候没有第i-1的字符。考虑到index，文中的i应该对应index的i-1 1234567891011121314public int numDecodings(String s) &#123; int len = s.length(); int[] dp = new int[len + 1]; dp[0] = 1; for(int i=1; i&lt;=len; i++)&#123; if(s.charAt(i-1) != &#x27;0&#x27;)&#123; dp[i] = dp[i-1]; &#125; if(i&gt;1 &amp;&amp; s.charAt(i-2) !=&#x27;0&#x27; &amp;&amp; 10 * (s.charAt(i-2)-&#x27;0&#x27;) + s.charAt(i-1) - &#x27;0&#x27; &lt;= 26)&#123; dp[i] += dp[i-2]; &#125; &#125; return dp[len];&#125; wed_115pm 62.Unique Paths1计算一个二维数组从左上到右下有多少个不同的路径，属于dp范例问题，用两个数组实现。 1234567891011121314public int uniquePaths(int m, int n) &#123; int[] first = new int[n]; int[] second = new int[n]; Arrays.fill(first, 1); for(int i=1; i&lt;m; i++)&#123; second[0] = 1; for(int j=1; j&lt;n; j++)&#123; second[j] = second[j-1] + first[j]; &#125; first = second; &#125; return first[n-1];&#125; 55.Jump Game1234567891011121314151617// 不算动态规划，是贪心问题，思路比较简单，注意当最长距离小于当前轮次就要结束循环了 public boolean canJump(int[] nums) &#123; int target = 0; for(int i=0; i&lt;nums.length; i++)&#123; if(i&gt;target)&#123; break; &#125; if(i+nums[i] &gt; target)&#123; target = i + nums[i]; &#125; &#125; if(target &gt;= nums.length - 1)&#123; return true; &#125; else &#123; return false; &#125; &#125; Graph 8133.Clone GraphGraph的基本结构 深度优先和广度优先遍历 123广度优先 queuequeue.addqueue.remove 12345678910111213141516// 深度优先 if(node == null)&#123; return null; &#125; if(visited.containsKey(node))&#123; return visited.get(node); &#125; List&lt;Node&gt; neighbors = new ArrayList(); Node cur = new Node(node.val, new ArrayList()); visited.put(node, cur); for(Node original:node.neighbors)&#123; Node newNode = cloneGraph(original); cur.neighbors.add(newNode); &#125; return cur; 123456789101112131415161718192021//广度优先if(node == null)&#123; return null;&#125;Map&lt;Node, Node&gt; visited = new HashMap();LinkedList&lt;Node&gt; queue = new LinkedList();queue.add(node); // rootvisited.put(node, new Node(node.val, new ArrayList&lt;Node&gt;()));while(!queue.isEmpty())&#123; Node head = queue.remove(); for (Node neighbor: head.neighbors) &#123; if(!visited.containsKey(neighbor))&#123; visited.put(neighbor, new Node(neighbor.val, new ArrayList&lt;Node&gt;())); queue.add(neighbor); &#125; visited.get(head).neighbors.add(visited.get(neighbor)); &#125;&#125;return visited.get(node); 207.Course Schedule拓扑图结构，有向图，无环。 BFS遍历，需要先将edges统计一下，先修prerequisite-&gt;List_advancedCourses. 然后定义每个高级课程的入度，当入度为0的时候，offer入queue. 然后按照顺序从queue中poll出。 1234567891011121314151617181920212223242526272829303132333435List&lt;List&lt;Integer&gt;&gt; edges = new ArrayList&lt;&gt;();int[] indeg;public boolean canFinish(int numCourses, int[][] prerequisites) &#123; int result = 0; for(int i=0; i&lt;numCourses; i++)&#123; edges.add(new ArrayList&lt;Integer&gt;()); &#125; indeg = new int[numCourses]; for(int[] info:prerequisites)&#123; edges.get(info[1]).add(info[0]); indeg[info[0]]++; &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for(int i=0; i&lt;numCourses; i++)&#123; if(indeg[i] == 0)&#123; queue.add(i); result++; &#125; &#125; while(!queue.isEmpty())&#123; int cur = queue.poll(); for(int ch:edges.get(cur))&#123; if(--indeg[ch] == 0)&#123; queue.offer(ch); result++; &#125; &#125; &#125; return result==numCourses;&#125; DFS遍历，全局valid变量表示是否有环，结果是返回这个图是否有环。valid有三个status，0是未访问，1是正在访问，如果正在访问的节点被访问了，说明有环，2是访问完毕。基本逻辑是循环便利所有的点，查看是否有环。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; List&lt;List&lt;Integer&gt;&gt; edges = new ArrayList(); int[] visited; boolean valid = true; public boolean canFinish(int numCourses, int[][] prerequisites) &#123; for(int i=0; i&lt;numCourses; i++)&#123; edges.add(new ArrayList&lt;Integer&gt;()); &#125; visited = new int[numCourses]; for(int[] info:prerequisites)&#123; edges.get(info[0]).add(info[1]); // 这个谁指向谁是无所谓的，也可以用edges.get(info[1]).add(info[0]); &#125; for(int i=0; i&lt;numCourses &amp;&amp; valid; ++i)&#123; if(visited[i] == 0)&#123; dfs(i); &#125; &#125; return valid; &#125; public void dfs(int u)&#123; visited[u] = 1; for(int v:edges.get(u))&#123; if(visited[v] == 0)&#123; dfs(v); if(!valid)&#123; //如果已经发现有闭环，就返回结果 return; &#125; &#125; else if(visited[v] == 1)&#123; // 发现闭环，将标志位置为false，然后结束往后的查询 valid = false; return; &#125; &#125; visited[u] = 2; // 当前课程已经查询过了，且已经可以成功学成 &#125;&#125; 417.Pacific Atlantic Water Flow略，我觉得这个题可以不看 200.Number of Islands方法1：深度优先dfs，把所有遍历到的地块都变成0，也就是变成海洋。本来应该用队列存储邻居，但是邻居恒定为4，就直接写了。 12345678910111213141516171819202122232425262728293031323334public int numIslands(char[][] grid) &#123; int m = grid.length; if(m==0)&#123; return 0; &#125; int n = grid[0].length; if(n==0)&#123; return 0; &#125; int output = 0; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(grid[i][j] == &#x27;1&#x27;)&#123; output++; dfs(grid, i, j); &#125; &#125; &#125; return output;&#125;public void dfs(char[][] grid, int i, int j)&#123; int m = grid.length; int n = grid[0].length; if(i&gt;=0 &amp;&amp; i&lt;m &amp;&amp; j&gt;=0 &amp;&amp; j&lt;n &amp;&amp; grid[i][j] == &#x27;1&#x27;)&#123; grid[i][j] = &#x27;0&#x27;; dfs(grid, i-1, j); dfs(grid, i+1, j); dfs(grid, i, j-1); dfs(grid, i, j+1); &#125;&#125; 方法2：广度优先遍历 也是将相邻的陆地翻转成’0’，用一个Queue存放下一层邻居并翻转。注意在Queue中存放的是(row * numberOfColumn + column) 这样二维数组就翻译成一个数字了。 123456789101112131415161718192021222324252627282930313233343536373839404142public int numIslands(char[][] grid) &#123; if (grid == null || grid.length == 0) &#123; return 0; &#125; int nr = grid.length; int nc = grid[0].length; int num_islands = 0; for (int r = 0; r &lt; nr; ++r) &#123; for (int c = 0; c &lt; nc; ++c) &#123; if (grid[r][c] == &#x27;1&#x27;) &#123; ++num_islands; grid[r][c] = &#x27;0&#x27;; Queue&lt;Integer&gt; neighbors = new LinkedList&lt;&gt;(); neighbors.add(r * nc + c); while (!neighbors.isEmpty()) &#123; int id = neighbors.remove(); int row = id / nc; int col = id % nc; if (row - 1 &gt;= 0 &amp;&amp; grid[row-1][col] == &#x27;1&#x27;) &#123; neighbors.add((row-1) * nc + col); grid[row-1][col] = &#x27;0&#x27;; &#125; if (row + 1 &lt; nr &amp;&amp; grid[row+1][col] == &#x27;1&#x27;) &#123; neighbors.add((row+1) * nc + col); grid[row+1][col] = &#x27;0&#x27;; &#125; if (col - 1 &gt;= 0 &amp;&amp; grid[row][col-1] == &#x27;1&#x27;) &#123; neighbors.add(row * nc + col-1); grid[row][col-1] = &#x27;0&#x27;; &#125; if (col + 1 &lt; nc &amp;&amp; grid[row][col+1] == &#x27;1&#x27;) &#123; neighbors.add(row * nc + col+1); grid[row][col+1] = &#x27;0&#x27;; &#125; &#125; &#125; &#125; &#125; return num_islands;&#125; 128.Longest Consecutive Sequence题目要求Time Complexity &#x3D; n 12345678910111213141516171819public int longestConsecutive(int[] nums) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int i:nums)&#123; set.add(i); &#125; int output = 0; for(int i:nums)&#123; if(!set.contains(i-1))&#123; int current = i; while(set.contains(++current))&#123; &#125; output = Math.max(current - i, output); &#125; &#125; return output;&#125; 题目要求 O(n)O(n)O(n) 复杂度。 用哈希表存储每个端点值对应连续区间的长度若数已在哈希表中：跳过不做处理若是新数加入：取出其左右相邻数已有的连续区间长度 left 和 right计算当前数的区间长度为：cur_length &#x3D; left + right + 1根据 cur_length 更新最大长度 max_length 的值更新区间两端点的长度值 1234567891011121314151617181920public int longestConsecutive(int[] nums) &#123; int n=nums.length; HashMap&lt;Integer,Integer&gt;map = new HashMap&lt;Integer,Integer&gt;(); int res = 0; for(int num:nums)&#123; if(!map.containsKey(num))&#123; int left = map.get(num-1)==null?0:map.get(num-1); int right = map.get(num+1)==null?0:map.get(num+1); int cur = 1+left+right; if(cur&gt;res)&#123; res = cur; &#125; map.put(num,cur); map.put(num-left,cur); map.put(num+right,cur); &#125; &#125; return res;&#125;// 二者相邻，此时这个连续序列只有left和right最远端可能还会出现一个相邻点，其余链上的数字都没有相邻点了，因此不用处理链上的数字。 269.Alien Dictionary 会员（Hard）261.Graph Valid Tree 会员123首先一棵树的特点是边数目+1等于点的数目，不符合直接返回false其次将入参转换成双向bidirected的二维ArrayList，从0开始遍历，用set记录已经遍历过的点最后对比set的size是否等于入参n的个数 323.Number of Connected Components in an undiredted Graph 会员Interval 557.Insert Interval1non-overlapping intervals 非重叠区间 12345678910111213141516171819202122232425262728// 分别考虑2种不交叉和1种相互交叉的情况 public int[][] insert(int[][] intervals, int[] newInterval) &#123; List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); int start = newInterval[0]; int end = newInterval[1]; boolean flag = true; for(int[] interval:intervals)&#123; if(interval[0] &gt; end)&#123; if(flag)&#123; flag = false; list.add(new int[]&#123;start, end&#125;); &#125; list.add(interval); &#125; else if(start &gt; interval[1])&#123; list.add(interval); &#125; else&#123; start = Math.min(start, interval[0]); end = Math.max(end, interval[1]); &#125; &#125; if(flag)&#123; flag = false; list.add(new int[]&#123;start, end&#125;); &#125; return list.toArray(new int[list.size()][]); &#125; 56.merge intervals123456789101112131415161718192021222324public int[][] merge(int[][] intervals) &#123; if(intervals.length==0)&#123; return new int[1][2]; &#125; Arrays.sort(intervals, new Comparator&lt;int[]&gt;()&#123; public int compare(int[] interval1, int[] interval2)&#123; return interval1[0] - interval2[0]; &#125; &#125;); List&lt;int[]&gt; list = new ArrayList(); int l = intervals[0][0]; int r = intervals[0][1]; for(int[] arr:intervals)&#123; if(arr[0]&gt;r)&#123; list.add(new int[]&#123;l, r&#125;); l = arr[0]; r = arr[1]; &#125; else &#123; r = Math.max(r, arr[1]); &#125; &#125; list.add(new int[]&#123;l, r&#125;); return list.toArray(new int[list.size()][]);&#125; 1234567891011121314151617181920public int[][] merge(int[][] intervals) &#123; if (intervals.length == 0) &#123; return new int[0][2]; &#125; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] interval1, int[] interval2) &#123; return interval1[0] - interval2[0]; &#125; &#125;); List&lt;int[]&gt; merged = new ArrayList&lt;int[]&gt;(); for (int i = 0; i &lt; intervals.length; ++i) &#123; int L = intervals[i][0], R = intervals[i][1]; if (merged.size() == 0 || merged.get(merged.size() - 1)[1] &lt; L) &#123; merged.add(new int[]&#123;L, R&#125;); &#125; else &#123; merged.get(merged.size() - 1)[1] = Math.max(merged.get(merged.size() - 1)[1], R); &#125; &#125; return merged.toArray(new int[merged.size()][]); &#125; 435.Non-overlapping Intervals12345678910111213141516171819// 如果按照start排序就取Math.min(r, intervals[i][1]);// 本代码按照end排序，所以r = intervals[i][1];即可public int eraseOverlapIntervals(int[][] intervals) &#123; if(intervals.length == 0)&#123; return 0; &#125; Arrays.sort(intervals, (item1, item2)-&gt;item1[1]-item2[1]); int output = 0; int r = intervals[0][1]; for(int i=1; i&lt;intervals.length; i++)&#123; if(intervals[i][0]&lt;r)&#123; output++; &#125; else&#123; r = intervals[i][1]; &#125; &#125; return output;&#125; Linked List 6206.Reverse Linked List反转链表，首先需要定义一个pre指针代表上一个Node，cur代表当前Node。 然后每一轮循环中新建一个Next，当前cur.next指向前pre，前pre指向当前cur，当前指向Next。 head已经是链表中的第一个节点了，不存在head.next是第一个节点。 1234567891011public ListNode reverseList(ListNode head) &#123; ListNode pre = null; ListNode cur = head; while(cur !=null)&#123; ListNode next = cur.next; cur.next = pre; pre=cur; cur = next; &#125; return pre;&#125; 141.Linked List Cycle 本题思路简单判断linkedlist是否有环。 思路是做一个set或者数组作为查重，当访问过的点再次被访问，就返回true。 12345678910public boolean hasCycle(ListNode head) &#123; Set&lt;ListNode&gt; set = new HashSet&lt;&gt;(); while(head!=null)&#123; if(!set.add(head))&#123; return true; &#125; head = head.next; &#125; return false;&#125; 21.Merge Two Sorted Lists要定义一个Head位置，否则splice之后找不到这个新链表的头了。 1234567891011121314151617public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123; ListNode preNode = new ListNode(-1); ListNode cur = preNode; while(list2 !=null &amp;&amp; list1 != null)&#123; if(list1.val &lt;= list2.val)&#123; cur.next = list1; cur = cur.next; list1 = list1.next; &#125; else&#123; cur.next = list2; cur = cur.next; list2 = list2.next; &#125; &#125; cur.next = list1 == null? list2 : list1; return preNode.next;&#125; 23.Merge k Sorted Lists (Hard)可以采用对21题目不对合并，或者两两合并，也可以用一个队列不断插入最小的节点的方式。 下面是利用PriorityQueue保证长度最大为k，每次poll都是当前队列中的最小的节点，并将它的下一个节点放入queue 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; class Status implements Comparable&lt;Status&gt; &#123; int val; ListNode ptr; Status(int val, ListNode ptr)&#123; this.val = val; this.ptr = ptr; &#125; public int compareTo(Status status2)&#123; return this.val - status2.val; &#125; &#125; public ListNode mergeKLists(ListNode[] lists) &#123; PriorityQueue&lt;Status&gt; queue = new PriorityQueue&lt;&gt;(); for(ListNode node: lists)&#123; if(node != null)&#123; queue.offer(new Status(node.val, node)); &#125; &#125; ListNode head = new ListNode(0); ListNode tail = head; while(!queue.isEmpty())&#123; Status f = queue.poll(); tail.next = f.ptr; tail = tail.next; if(f.ptr.next != null)&#123; queue.offer(new Status(f.ptr.next.val, f.ptr.next)); &#125; &#125; return head.next; &#125;&#125; 19.Remove Nth Node From End of List双指针 1234567891011121314151617public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0, head); ListNode left = dummy; ListNode right = head; for(int i=0; i&lt;n; i++)&#123; if(right == null)&#123; return head; &#125; right = right.next; &#125; while(right != null)&#123; left = left.next; right = right.next; &#125; left.next = left.next.next; return dummy.next;&#125; 143.Reorder List自己想到的方法，将后半段压入stack中，注意寻找中心点奇数偶数不同 1234567891011121314151617181920212223242526272829303132public void reorderList(ListNode head) &#123; if(head == null)&#123; return; &#125; Deque&lt;ListNode&gt; stack = new LinkedList(); ListNode slowNode = head; ListNode quickNode = head; while(quickNode.next !=null &amp;&amp; quickNode.next.next!=null)&#123; slowNode = slowNode.next; quickNode = quickNode.next.next; &#125; ListNode secondNode = slowNode.next; ListNode midNode = slowNode; while(secondNode!=null)&#123; stack.push(secondNode); secondNode = secondNode.next; &#125; ListNode firstNode = new ListNode(-1, head); ListNode output = new ListNode(-1, head); while(stack.size()!=0)&#123; firstNode.next = head; head = head.next; firstNode = firstNode.next; firstNode.next = stack.pop(); firstNode = firstNode.next; &#125; if(head==slowNode)&#123; firstNode.next = head; &#125; head.next = null; head = output.next;&#125; Matrix 这一章都是体力活，面试大概率不考73.Set Matrix 矩阵 Zeroes遍历两次二维数组，记录横纵坐标 12345678910111213141516171819202122232425262728public void setZeroes(int[][] matrix) &#123; if(matrix.length == 0)&#123; return; &#125; int m = matrix.length; int n = matrix[0].length; Set&lt;Integer&gt; col = new HashSet&lt;&gt;(); Set&lt;Integer&gt; row = new HashSet&lt;&gt;(); for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(matrix[i][j] == 0)&#123; row.add(i); col.add(j); &#125; &#125; &#125; for(int i=0; i&lt;m; i++)&#123; if(row.contains(i))&#123; matrix[i] = new int[n]; continue; &#125; for(int j=0; j&lt;n; j++)&#123; if(col.contains(j))&#123; matrix[i][j] = 0; &#125; &#125; &#125;&#125; 54.Spiral Matrix官方解法太麻烦，下面评论给出新思路 123456789101112131415161718192021222324252627public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return ans; int u = 0, d = matrix.length - 1; int l = 0, r = matrix[0].length - 1; while (true) &#123; for (int i = l; i &lt;= r; i++) &#123; // 左-&gt;右 ans.add(matrix[u][i]); &#125; if (++u &gt; d) break; for (int i = u; i &lt;= d; i++) &#123; // 上-&gt;下 ans.add(matrix[i][r]); &#125; if (--r &lt; l) break; for (int i = r; i &gt;= l; i--) &#123; // 右-&gt;左 ans.add(matrix[d][i]); &#125; if (--d &lt; u) break; for (int i = d; i &gt;= u; i--) &#123; // 下-&gt;上 ans.add(matrix[i][l]); &#125; if (++l &gt; r) break; &#125; return ans;&#125; 48.Rotate Image先上下翻转，再对角线翻转 12345678910111213141516171819202122public void rotate(int[][] matrix) &#123; int n = matrix.length; // 上下翻转 for (int i = 0; i &lt; n / 2; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; int tmp = matrix[i][j]; matrix[i][j] = matrix[n - 1 -i][j]; matrix[n - 1 -i][j] = tmp; &#125; &#125; // 左斜对角线(\\)翻转 for(int i = 0; i &lt; n; i++) &#123; // 第二层遍历终止条件为 j &lt; i for(int j = 0; j &lt; i; j++) &#123; int tmp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = tmp; &#125; &#125;&#125; 79.Word Search12345678910111213141516171819202122232425262728293031323334353637383940public boolean exist(char[][] board, String word) &#123; int h = board.length, w = board[0].length; boolean[][] visited = new boolean[h][w]; for (int i = 0; i &lt; h; i++) &#123; for (int j = 0; j &lt; w; j++) &#123; visited = new boolean[h][w]; boolean flag = check(board, visited, i, j, word, 0); if (flag) &#123; return true; &#125; &#125; &#125; return false; &#125; public boolean check(char[][] board, boolean[][] visited, int i, int j, String s, int k) &#123; if (board[i][j] != s.charAt(k)) &#123; return false; &#125; else if (k == s.length() - 1) &#123; return true; &#125; visited[i][j] = true; int[][] directions = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;; boolean result = false; for (int[] dir : directions) &#123; int newi = i + dir[0], newj = j + dir[1]; if (newi &gt;= 0 &amp;&amp; newi &lt; board.length &amp;&amp; newj &gt;= 0 &amp;&amp; newj &lt; board[0].length) &#123; if (!visited[newi][newj]) &#123; boolean flag = check(board, visited, newi, newj, s, k + 1); if (flag) &#123; result = true; break; &#125; &#125; &#125; &#125; visited[i][j] = false; return result; &#125; String3.Longest Substring Without Repeating Characters滑动窗口的概念反应不过来，我用的是Map记录字符出现的最新位置的方法 字符串长度用str.length() 根据循环中的字符是否是重复字符，来决定left的边界是否右移。对于外循环来说，只要遍历所有字符，知道字符串结束，每轮i，会有对应i的最佳不重复的left。对比每轮的长度，得到最后的logest 1234567891011121314151617// 用map记录字符出现的lastest index，每次比较start index和output，最后返回outputpublic int lengthOfLongestSubstring(String s) &#123; int output = 0; int start = 0; Map&lt;Character, Integer&gt; hashmap = new HashMap(); int len = s.length(); for(int i=0; i&lt;len; i++)&#123; Character ch = s.charAt(i); if(hashmap.containsKey(ch))&#123; start = Math.max(hashmap.get(ch) + 1, start); &#125; output = Math.max(1+i-start, output); hashmap.put(ch, i); &#125; return output;&#125; 424.Longest Repeating Character Replacement滑动窗口思路，只用记录滑动窗口的长度。窗口长度只会变长，每次left向左收敛只收敛1。 记录每个字符出现的频率，left向右走一步就频率减一，right向右走一步就频率加1. 当窗口长度等于最大的字符频率+k。如果窗口长了，则left+1，然后取每次与result比较 1char[] charArray = s.toCharArray(); 滑动窗口 12345678910111213141516171819public int characterReplacement(String s, int k) &#123; int output = 0; int left = 0; int right = 0; int len = s.length(); int maxn = 0; int[] record = new int[26]; for(int i=0; i&lt;len; i++)&#123; char cur = s.charAt(i); record[cur-&#x27;A&#x27;]++; maxn = Math.max(record[cur-&#x27;A&#x27;], maxn); if(right+1-left&gt;maxn + k)&#123; record[s.charAt(left) - &#x27;A&#x27;]--; left++; &#125; right++; &#125; return right - left;&#125; 76.Minimum Window Substring （Hard）242.Valid Anagram （掌握题不用看）相同字母异序词 非常简单的题，哈希表一次过 长度不同直接返回false，用一个长度26的数组统计频率，然后再统计另一个字符串的字符频率，出现负数直接返回false。 49.Group Anagrams按照字符分组 题目本身不复杂，用到的方法有点繁琐，注意返回值的写法 123456新建HashMap&lt;String, List&lt;String&gt;&gt; key表示每个item的字母排序，value是实际的itemstr.toCharArray()new String(array)map.getOrDefault(key, new ArrayList&lt;String&gt;())return new ArrayList&lt;List&lt;String&gt;&gt;(map.values()); 123456789101112public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String, List&lt;String&gt;&gt; map = new HashMap(); for(String str:strs)&#123; char[] cur = str.toCharArray(); Arrays.sort(cur); String key = new String(cur); List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;String&gt;()); list.add(str); map.put(key, list); &#125; return new ArrayList&lt;List&lt;String&gt;&gt;(map.values());&#125; 20.Valid Parentheses(圆括号)本题考察对栈stack的运用，大量方法需要记住 1234567891011121314151617//用栈的原理，先让一个特殊字符?入栈，如果这个特殊字符出栈（被调取），则返回false。//做括号就入栈，右括号就从栈里匹配左括号出栈，类似扑克牌抽对。//匹配结束后，看栈里的字符是否为1，?避免有左括号在栈中//或者用peep()也可以,空栈返回null，null和Character可以==比较，但不能和基本数据类型比较private static final Map&lt;Character,Character&gt; map = new HashMap&lt;Character,Character&gt;()&#123;&#123; put(&#x27;&#123;&#x27;,&#x27;&#125;&#x27;); put(&#x27;[&#x27;,&#x27;]&#x27;); put(&#x27;(&#x27;,&#x27;)&#x27;);&#125;&#125;;public boolean isValid(String s) &#123; // if(s.length() &gt; 0 &amp;&amp; !map.containsKey(s.charAt(0))) return false; LinkedList&lt;Character&gt; stack = new LinkedList&lt;Character&gt;() &#123;&#123; add(&#x27;?&#x27;); &#125;&#125;; for(Character c : s.toCharArray())&#123; if(map.containsKey(c)) stack.addLast(c); else if(map.get(stack.removeLast()) != c) return false; &#125; return stack.size() == 1;&#125; 125.Valid Palindrome左右双指针 1234判断字符是不是字母或者数字Character.isLetterOrDigit(s.charAt(left))sgood.append(Character.toLowerCase(ch));StringBuffer sgood_rev = new StringBuffer(sgood).reverse(); 123456789101112131415161718public boolean isPalindrome(String s) &#123; StringBuffer sb = new StringBuffer(); for(char c:s.toCharArray())&#123; if(Character.isLetterOrDigit(c))&#123; sb.append(Character.toUpperCase(c)); &#125; &#125; int r = sb.length()-1; int l = 0; while(l&lt;r)&#123; if(sb.charAt(l) != sb.charAt(r))&#123; return false; &#125; l++; r--; &#125; return true;&#125; 5.Longest Palindromic Substring1.动态规划，策略详见 12https://alchemist-al.com/algorithms/longest-palindromic-substring 分为三种情况：1. 长度为1，每个字符都是palindrome 2. 长度为2，则对比这2个字符 3. 长度大于2，则用状态转移方程则先对比，再查看第i+1, j-1的结果。 2.中心扩展 for循环遍历每个item作为中心点，以中心点或者中心点和中心点+1作为中心向两边扩张，直到不是回文。 记录每次的最大记录。 123456789101112131415161718192021222324252627282930313233343536373839404142public String longestPalindrome(String s) &#123; if(s.length()&lt;2)&#123; return s; &#125; int output = 0; int outputl = 0; int outputr = 0; int len = s.length(); for(int i=0; i&lt;len; i++)&#123; int l = i; int r = i; while(l&gt;=0 &amp;&amp; r&lt;len)&#123; if(s.charAt(l) == s.charAt(r))&#123; if(r-l+1 &gt; output)&#123; outputr=r; outputl = l; output= r-l+1; &#125; l--; r++; &#125; else&#123; break; &#125; &#125; l = i; r = i+1; while(l&gt;=0 &amp;&amp; r&lt;len)&#123; if(s.charAt(l) == s.charAt(r))&#123; if(r-l+1 &gt; output)&#123; outputr=r; outputl = l; output= r-l+1; &#125; l--; r++; &#125; else&#123; break; &#125; &#125; &#125; return s.substring(outputl, outputr+1);&#125; 3.马拉车，这是真复杂，不想看了 647.Palindromic Substrings其实跟上边那题目一样，只是返回值不同 1234567891011121314151617181920212223242526272829303132public int countSubstrings(String s) &#123; if(s.length()&lt;2)&#123; return s.length(); &#125; int len = s.length(); int result = 0; for(int i=0; i&lt;len; i++)&#123; int l = i; int r = i; while(l&gt;=0 &amp;&amp; r&lt;len)&#123; if(s.charAt(l) == s.charAt(r))&#123; result++; l--; r++; &#125; else&#123; break; &#125; &#125; l = i; r = i+1; while(l&gt;=0 &amp;&amp; r&lt;len)&#123; if(s.charAt(l) == s.charAt(r))&#123; result++; l--; r++; &#125; else&#123; break; &#125; &#125; &#125; return result; &#125; 计算Palin drome的时候，要考虑奇数偶数，用小于2n-1限制i，i&#x2F;2和i&#x2F;2+n%2确定左右边界。当i为偶数，左右边界相同，i为奇数，r比l大1，左右边界以中心线为对称线。 1234567801234i n 2n-1 L R0 5 9 0 01 5 9 0 12 1 13 1 27 5 9 3 48 5 9 4 4 第二种方法是Manacher 271.encode and decode strings 这题是会员题目。。。12345678910111213141516171819public String encode(List&lt;String&gt; strs)&#123; StringBuilder sb = new StringBuilder(); for(String str : strs)&#123; sb.append(str.length()).append(&quot;/&quot;).append(str); &#125; return sb.toString();&#125;public List&lt;String&gt; decode(String s)&#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); int i=0; while(i&lt;s.length())&#123; int slash = s.indexOf(&#x27;/&#x27;, i); int size = Integer.valueOf(s.substring(i, slash)); res.add(s.substring(slash + 1, slash + 1 + size)); i = slash + 1 + size; // 防止非各位数字 for example: 16 &#125; return res;&#125; Tree104.Maximum Depth of Binary Tree如果用DFS，则 max(l,r)+1 BFD, 则每次扩展到下一层深度+1 12345678910public int maxDepth(TreeNode root) &#123; int ans = 0; if(root == null)&#123; return 0; &#125; else&#123; int left = maxDepth(root.left) + 1; int right = maxDepth(root.right) + 1; return Math.max(left, right); &#125;&#125; 1234567891011121314151617181920212223 public int maxDepth(TreeNode root) &#123;if(root == null)&#123; return 0; &#125; int ans = 0; Queue&lt;TreeNode&gt; queue = new LinkedList(); queue.offer(root); while(!queue.isEmpty())&#123; int size = queue.size(); while(size &gt; 0)&#123; TreeNode node = queue.poll(); if(node.left != null)&#123; queue.offer(node.left); &#125; if(node.right != null)&#123; queue.offer(node.right); &#125; size--; &#125; ans++; &#125;return ans; &#125; 100.Same Tree判断两个binary tree 是否 identical， 用BFS，DFS. BFS最后要看Queue里面是否为空，否则二者长度不同，肯定不相等。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/ public boolean isSameTree(TreeNode p, TreeNode q) &#123; // if(p==null &amp;&amp; q==null)&#123; // return true; // &#125; // if(p!=null &amp;&amp; q!=null &amp;&amp; p.val == q.val)&#123; // // 下一层 // return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); // &#125; else &#123; // return false; // &#125; // &#125; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p==null &amp;&amp; q==null)&#123; return true; &#125; else if(p==null ^ q==null) &#123; return false; &#125; else&#123; // 都不为空就真的要对比值 if(p.val != q.val)&#123; return false; &#125; else&#123; Queue&lt;TreeNode&gt; q1 = new LinkedList(); Queue&lt;TreeNode&gt; q2 = new LinkedList(); q1.offer(p); q2.offer(q); while(!q1.isEmpty() &amp;&amp; !q2.isEmpty())&#123; TreeNode one= q1.poll(); TreeNode two= q2.poll(); if(one.val != two.val)&#123; return false; &#125; TreeNode l1 = one.left; TreeNode r1 = one.right; TreeNode l2 = two.left; TreeNode r2 = two.right; if(l1==null ^ l2==null)&#123; return false; &#125; if(r1==null ^ r2==null)&#123; return false; &#125; if(l1!=null &amp;&amp; l2!=null)&#123; q1.offer(l1); q2.offer(l2); &#125; if(r1!=null &amp;&amp; r2!=null)&#123; q1.offer(r1); q2.offer(r2); &#125; &#125; return q1.isEmpty() &amp;&amp; q2.isEmpty(); &#125; &#125; &#125; 226.Invert Binary Tree左右翻转 123456789public TreeNode invertTree(TreeNode root) &#123; if(root == null)&#123; return root; &#125; TreeNode temp = root.left; root.left = invertTree(root.right); root.right=invertTree(temp); return root;&#125; 124.Binary Tree Maximum Path Sum （Hard）递归，返回包含当前节点的最大半截链。返回结果是历史最大长链。 123456789101112131415161718public int ans = Integer.MIN_VALUE;public int maxPathSum(TreeNode root) &#123; // 返回当前节点的最大贡献值 // return the maximum donation of current node maxDon(root); return ans; // 因为返回的值，不是递归的返回值(含当前节点的半截链)，是其中的链最大值&#125;public int maxDon(TreeNode root)&#123; if(root == null)&#123; return 0; &#125; int left = Math.max(0, maxDon(root.left)); int right = Math.max(0, maxDon(root.right)); int donation = root.val + left + right; ans = Math.max(ans, donation); return root.val + Math.max(left, right);&#125; 123456789101112131415161718192021public TreeNode invertTree(TreeNode root) &#123; if(root == null)&#123; return root; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; TreeNode node = queue.poll(); TreeNode temp = node.left; node.left = node.right; node.right = temp; if(node.left != null)&#123; queue.offer(node.left); &#125; if(node.right!=null)&#123; queue.offer(node.right); &#125; &#125; return root;&#125; 102.Binary Tree Level Order Traversal广度优先遍历，要求结果一层一个数组（list） 12注意generics的写法List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;List&lt;Integer&gt;&gt;(); 1234567891011121314151617181920212223242526public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (root == null) &#123; return ret; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; List&lt;Integer&gt; level = new ArrayList&lt;Integer&gt;(); int currentLevelSize = queue.size(); for (int i = 1; i &lt;= currentLevelSize; ++i) &#123; TreeNode node = queue.poll(); level.add(node.val); if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; &#125; ret.add(level); &#125; return ret;&#125; 297.Serialize and Deserialize Binary Tree123数组转ListArrays.asList(strings[])List&lt;String&gt; list = new ArrayList(Arrays.asList(strings[])); 体力活，不想看，官方是先序遍历 572.Subtree of Another Tree这不遍历加对比么，样本要一直对比到Null节点 遍历对比的时间负责都是 O(∣s∣×∣t∣)，后面的两种方法可以缩短发杂度，但比较复杂 105.Construct Binary Tree from Preorder and Inorder Traversal用前序遍历和中序遍历构造二叉树 用确定根节点的方法可以构建找个结构，Otime为n，每次调用递归可以得到一个根节点的位置。 123456789101112131415161718192021222324252627282930313233343536// preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]private Map&lt;Integer, Integer&gt; indexMap;public TreeNode myBuildTree(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) &#123; if (preorder_left &gt; preorder_right) &#123; return null; &#125; // 前序遍历中的第一个节点就是根节点 int preorder_root = preorder_left; // 在中序遍历中定位根节点 int inorder_root = indexMap.get(preorder[preorder_root]); // 先把根节点建立出来 TreeNode root = new TreeNode(preorder[preorder_root]); // 得到左子树中的节点数目 int size_left_subtree = inorder_root - inorder_left; // 递归地构造左子树，并连接到根节点 // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素 root.left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1); // 递归地构造右子树，并连接到根节点 // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素 root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right); return root;&#125;public TreeNode buildTree(int[] preorder, int[] inorder) &#123; int n = preorder.length; // 构造哈希映射，帮助我们快速定位根节点 indexMap = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; n; i++) &#123; indexMap.put(inorder[i], i); &#125; return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);&#125; 98.Validate Binary Search Tree230.Kth Smallest Element in a BST1中序遍历，基本思想是利用Stack，两个While循环，内循环压入左节点，外循环弹出节点并且压入右侧节点 1234567891011121314151617// 中序遍历public int kthSmallest(TreeNode root, int k) &#123; Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); while(!stack.isEmpty() || root!=null)&#123; while(root!=null)&#123; stack.push(root); root = root.left; &#125; TreeNode cur = stack.pop(); k--; if(k==0)&#123; return cur.val; &#125; root = cur.right; &#125; return 0;&#125; 1234567891011121314151617181920public int kthSmallest(TreeNode root, int k) &#123; int leftNodes = countNodes(root.left); if(leftNodes &lt; k - 1)&#123; //答案存在右子树中 return kthSmallest(root.right,k - leftNodes - 1); &#125;else if(leftNodes == k - 1)&#123; return root.val; &#125;else&#123; return kthSmallest(root.left,k); &#125;&#125;//左神递归套路分析左右子树返回信息只需要节点数，因此无需额外定义数据结构public int countNodes(TreeNode root)&#123; //base case返回0 if(root == null) return 0; //递归处理左右子树并接收返回值 int leftNodes = countNodes(root.left); int rightNodes = countNodes(root.right); //判断分析本层递归返回值的具体值 return leftNodes + rightNodes + 1;&#125; 235.Lowest Common Ancestor of Binary Search Tree1234567891011121314// 一次遍历法public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; TreeNode ancestor = root; while(ancestor != null)&#123; if(ancestor.val &gt; p.val &amp;&amp; ancestor.val &gt; q.val)&#123; ancestor = ancestor.left; &#125; else if(ancestor.val &lt; p.val &amp;&amp; ancestor.val &lt; q.val)&#123; ancestor = ancestor.right; &#125; else&#123; break; &#125; &#125; return ancestor;&#125; Heap23.重复题目，不做展示 347.Top K Frequent Elements123456789101112131415161718192021222324252627282930// 最小堆public int[] topKFrequent(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; occurrences = new HashMap&lt;Integer, Integer&gt;(); for (int num : nums) &#123; occurrences.put(num, occurrences.getOrDefault(num, 0) + 1); &#125; // int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数 PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;() &#123; public int compare(int[] m, int[] n) &#123; return m[1] - n[1]; &#125; &#125;); for (Map.Entry&lt;Integer, Integer&gt; entry : occurrences.entrySet()) &#123; int num = entry.getKey(), count = entry.getValue(); if (queue.size() == k) &#123; if (queue.peek()[1] &lt; count) &#123; queue.poll(); queue.offer(new int[]&#123;num, count&#125;); &#125; &#125; else &#123; queue.offer(new int[]&#123;num, count&#125;); &#125; &#125; int[] ret = new int[k]; for (int i = 0; i &lt; k; ++i) &#123; ret[i] = queue.poll()[0]; &#125; return ret;&#125; 295.Find Median from Data Stream (Hard)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/tags/leetcode/"}]},{"title":"Leetcode169","slug":"Leetcode169","date":"2023-09-11T19:00:00.000Z","updated":"2024-01-02T01:31:03.394Z","comments":true,"path":"2023/09/11/Leetcode169/","permalink":"http://example.com/2023/09/11/Leetcode169/","excerpt":"","text":"插件 1https://github.com/SimplifyJobs/Summer2024-Internships 169地址 1https://www.techinterviewhandbook.org/grind75 [TOC] Week11.Two SumMap要有泛型 hashmap.containsKey(i) hashmap.get(i) hashmap.put(i1,i2) 20.Valid Parentheseshashmap初始化可以写为，注意结尾的引号 123private static final Map&lt;Character, Character&gt; map = new HashMap()&#123;&#123; put(&#x27;(&#x27;,&#x27;)&#x27;);put(&#x27;[&#x27;,&#x27;]&#x27;);put(&#x27;&#123;&#x27;,&#x27;&#125;&#x27;);&#125;&#125;; str.length() 注意有括号Parentheses Stack可以用linkedlist实现，方法是addLast(c)和removeLast()这个会得到删除的元素 stack.size() 遍历一个字符串时候 Character c:s.toCharArray() 按照index找字符串中的字符时候 str.charAt(index) 防止一上来加入的字符就是后半个括号，向往stack里加一个特殊字符? 也可以使用Deque“代课” deque.pop() deque.push() deque.peek() 21.Merge Two Sorted Lists递归 链表指针的移动 121.Best Time to Buy and Sell Stock卖股票得最大利润 简单题需要记录当前最大利润和记录当前最低点 125.Valid Palindrome 回型文2种思路，1是新建字符串拼接反转后对比，2是在原有基础上双指针对比 StringBuffer的&#x3D;&#x3D;比较的是地址，equals方法也没被重写，所以对比两个字符串的值等不等需要先toString()再equals() 12345Character.isLetterOrDigit()Character.toLowerCase(ch) Character.toUpperCase(ch) 226.Invert Binary Tree递归，本质是深度优先遍历 depth first traversal如果root为null, 0 就return, 否则做必要动作，然后return root 栈迭代，本质是广度优先遍历 breadth first traversal这个套路是先把root节点加到栈里， 242.Valid Anagram 相同字母异序词 ‘A’ 的ASCII码值是 65。 ‘a’ 的ASCII码值是 97。 ‘Z’ 的ASCII码值是 90。 ‘z’ 的ASCII码值是 122。 第一种方法是Arrays.sort() 然后Arrays.equals(a1, a2) 第二种是用一个alphabet的长度26的array维护统计字符个数，然后看是否数量相等 704.Binary Search二分查找 简单题 733.Flood Fill队列也是用LinkedList实现 queue.offer() 代表添加queue.poll() 删除 第一种方法是Breadth first traversal 什么时候用Queue, 什么时候用Stack需要甄别 这种二维数组画pixel都要考虑边界是否越界 123if (mx &gt;= 0 &amp;&amp; mx &lt; image.length &amp;&amp; my &gt;= 0 &amp;&amp; my &lt; image[0].length) &#123; dfs(image, mx, my, currColor, color);&#125; 235.Lowest Common Ancestor of a Binary Search Tree找最小祖先 这是Binary Search Tree的正向利用 110.Balanced Binary Tree首先height-balanced Height-Balanced A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one. 这个题目用递归，一个方法找当前的height, 一个方法查看当前节点是否balanced 2 just calculate height of current node. If the any descendant of current node is unbalanced, the current node would be unbalanced too. 这种方法just calculate the height of current node. 141.Linked List CycleHashSet 或者 快慢指针 HashSet 中 set.add()方法会返回是否添加成功，因此可以判断是否有重复快慢指针的精髓在于slow每次走一步slow.next, fast每次走两步fast.next.next 232.Implement Queue using Stacks原理是一个栈是入栈，一个栈是出栈，出的时候先看出栈，出栈为空的时候需要有一个从入栈到出栈的压入过程 12345private void in2out() &#123; while (!inStack.isEmpty()) &#123; outStack.push(inStack.pop()); &#125;&#125; Week 2278.First Bad Version本质是binary search，寻找相同情况最左点。 注意这个不是找对应数字，这是找连续数字的最左点。 383，Ransom Note 勒索信str转字符数组str.toCharArray() map.getOrDefault(c, 0) 可以用数组存储26个字符的方式，我用的map存储，两个for循环 Week 357.Insert Interval往一个顺序的且不重叠non-overlapping区间中插入一个新的区间，不能重叠（合并新区间和老区间重叠的部分） 给的是int的二位数组，先新建一个list，最后再循环一边list，把答案导入新的int二维数组。重点是循环原数组，然后将老数组中每一个区间和新区间比较，一共三种情况，重叠就合并。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/tags/leetcode/"}]}],"categories":[{"name":"English","slug":"English","permalink":"http://example.com/categories/English/"},{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/categories/leetcode/"}],"tags":[{"name":"English learning","slug":"English-learning","permalink":"http://example.com/tags/English-learning/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"interview","slug":"interview","permalink":"http://example.com/tags/interview/"},{"name":"en","slug":"en","permalink":"http://example.com/tags/en/"},{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/tags/leetcode/"}]}